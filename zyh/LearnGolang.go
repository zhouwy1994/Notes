1.内存对其，golang默认是按照c/c++的内存对其方式，为什么要使用内存对其机制
(1)平台(移植性):不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况
(2)性能(提高效率):若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访
问就可以完成读取动作，这显然高效很多，是标准的空间换时间做法
内存对其原则:
在不同平台上的编译器都有自己默认的 “对齐系数”。一般来讲，我们常用的 x86(32bit) 平台的系数为 4；x86_64(64bit) 平台系数为 8
一个结构体内的对其系数取决于最大的成员字节数，但是超过平台系数后，以平台系数作为最终的的对其系数。
type T struct {
	a byte
	b uint16 // 以最大成员字节作为对其系数unsafe.Sizeof(*new(T)) == 4
}

有一点需要注意，在32bit下访问int64位的结构体成员指针时，次结构一定要按照8字节对其，否在会报panic,eg:
type T1 struct {
	a int32
	b int64 // 32位下unsafe.Sizeof(*new(T)) == 12
}
如果此时调用:v:=T1{};atomic.AddInt64(&v.B, 1) // 会报panic
解决方案,在结构体内加一个占位符，使结构体的占位为8的倍数
type T1 struct {
	a int32
	_ int32
	b int64 // 32位下unsafe.Sizeof(*new(T)) == 12
}

当结构体中包含数组时，只要最终所占字节是当前结构体对其系数的倍数就行

2.unsafe.Alignof(v) 就是专门用来输出对齐系数的函数,一版对其系数为1、2、4、8

3.可用binary.Size()方法求得结构体在以1为对其系数下所占内存数，但是结构体成员只支持基础数据类型，不支持复合数据类型

4.context是一种在处理慢请求时开多个goroutine时，连接断开时退出众多goroutine的一种手段,通过派生的方式生成子context，父context调用cacel函数是，各子context都能收到信号

5.golang的两个常用的包管理工具vendor(第三方 将依赖都放在工程目录下),go 1.12版本的go modules,构建时拉去依赖(方便管理依赖版本)

6.UPX+压缩golang可执行程序,upx压缩golang可执行文件首先加上编译参数-ldflags,go build -ldflags '-w -s' main.go ,upx main

7.正则表达式查找子项使用Find*Submatch类函数，该函数会返回所有已经匹配的结果通过下标取